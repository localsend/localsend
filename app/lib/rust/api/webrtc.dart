// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'package:localsend_app/rust/api/model.dart';
import 'package:localsend_app/rust/frb_generated.dart';
import 'package:uuid/uuid.dart';

part 'webrtc.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `sign`

Stream<WsServerMessage> connect(
        {required String uri,
        required ProposingClientInfo info,
        required String privateKey,
        required FutureOr<void> Function(LsSignalingConnection)
            onConnection}) =>
    RustLib.instance.api.crateApiWebrtcConnect(
        uri: uri,
        info: info,
        privateKey: privateKey,
        onConnection: onConnection);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LsSignalingConnection>>
abstract class LsSignalingConnection implements RustOpaqueInterface {
  Future<RtcReceiveController> acceptOffer(
      {required List<String> stunServers,
      required WsServerSdpMessage offer,
      required String privateKey,
      ExpectingPublicKey? expectingPublicKey,
      PinConfig? pin});

  Future<RtcSendController> sendOffer(
      {required List<String> stunServers,
      required UuidValue target,
      required String privateKey,
      ExpectingPublicKey? expectingPublicKey,
      PinConfig? pin,
      required List<FileDto> files});

  Future<void> updateInfo({required ClientInfoWithoutId info});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RTCFileReceiver>>
abstract class RtcFileReceiver implements RustOpaqueInterface {
  Future<String> getFileId();

  Stream<Uint8List> receive();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RTCFileSender>>
abstract class RtcFileSender implements RustOpaqueInterface {
  Future<void> send({required List<int> data});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RTCReceiveController>>
abstract class RtcReceiveController implements RustOpaqueInterface {
  Future<void> decline();

  Stream<RTCFileError> listenError();

  Future<List<FileDto>> listenFiles();

  Stream<RtcFileReceiver> listenReceiving();

  Stream<RTCStatus> listenStatus();

  Future<void> sendFileStatus({required RTCSendFileResponse status});

  Future<void> sendPin({required String pin});

  Future<void> sendSelection({required Set<String> selection});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RTCSendController>>
abstract class RtcSendController implements RustOpaqueInterface {
  Stream<RTCFileError> listenError();

  Future<Set<String>> listenSelectedFiles();

  Stream<RTCStatus> listenStatus();

  Future<RtcFileSender> sendFile({required String fileId});

  Future<void> sendPin({required String pin});
}

class ClientInfo {
  final UuidValue id;
  final String alias;
  final String version;
  final String? deviceModel;
  final DeviceType? deviceType;
  final String token;

  const ClientInfo({
    required this.id,
    required this.alias,
    required this.version,
    this.deviceModel,
    this.deviceType,
    required this.token,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      alias.hashCode ^
      version.hashCode ^
      deviceModel.hashCode ^
      deviceType.hashCode ^
      token.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClientInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          alias == other.alias &&
          version == other.version &&
          deviceModel == other.deviceModel &&
          deviceType == other.deviceType &&
          token == other.token;
}

class ClientInfoWithoutId {
  final String alias;
  final String version;
  final String? deviceModel;
  final DeviceType? deviceType;
  final String token;

  const ClientInfoWithoutId({
    required this.alias,
    required this.version,
    this.deviceModel,
    this.deviceType,
    required this.token,
  });

  @override
  int get hashCode =>
      alias.hashCode ^
      version.hashCode ^
      deviceModel.hashCode ^
      deviceType.hashCode ^
      token.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClientInfoWithoutId &&
          runtimeType == other.runtimeType &&
          alias == other.alias &&
          version == other.version &&
          deviceModel == other.deviceModel &&
          deviceType == other.deviceType &&
          token == other.token;
}

class ExpectingPublicKey {
  final String publicKey;

  /// "ed25519" or "rsa-pss"
  final String kind;

  const ExpectingPublicKey({
    required this.publicKey,
    required this.kind,
  });

  @override
  int get hashCode => publicKey.hashCode ^ kind.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ExpectingPublicKey &&
          runtimeType == other.runtimeType &&
          publicKey == other.publicKey &&
          kind == other.kind;
}

class PinConfig {
  final String pin;
  final int maxTries;

  const PinConfig({
    required this.pin,
    required this.maxTries,
  });

  @override
  int get hashCode => pin.hashCode ^ maxTries.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PinConfig &&
          runtimeType == other.runtimeType &&
          pin == other.pin &&
          maxTries == other.maxTries;
}

class ProposingClientInfo {
  final String alias;
  final String version;
  final String? deviceModel;
  final DeviceType? deviceType;

  const ProposingClientInfo({
    required this.alias,
    required this.version,
    this.deviceModel,
    this.deviceType,
  });

  @override
  int get hashCode =>
      alias.hashCode ^
      version.hashCode ^
      deviceModel.hashCode ^
      deviceType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProposingClientInfo &&
          runtimeType == other.runtimeType &&
          alias == other.alias &&
          version == other.version &&
          deviceModel == other.deviceModel &&
          deviceType == other.deviceType;
}

class RTCFileError {
  final String fileId;
  final String error;

  const RTCFileError({
    required this.fileId,
    required this.error,
  });

  @override
  int get hashCode => fileId.hashCode ^ error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RTCFileError &&
          runtimeType == other.runtimeType &&
          fileId == other.fileId &&
          error == other.error;
}

class RTCSendFileResponse {
  final String id;
  final bool success;
  final String? error;

  const RTCSendFileResponse({
    required this.id,
    required this.success,
    this.error,
  });

  @override
  int get hashCode => id.hashCode ^ success.hashCode ^ error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RTCSendFileResponse &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          success == other.success &&
          error == other.error;
}

@freezed
sealed class RTCStatus with _$RTCStatus {
  const RTCStatus._();

  const factory RTCStatus.sdpExchanged() = RTCStatus_SdpExchanged;
  const factory RTCStatus.connected() = RTCStatus_Connected;
  const factory RTCStatus.pinRequired() = RTCStatus_PinRequired;
  const factory RTCStatus.tooManyAttempts() = RTCStatus_TooManyAttempts;
  const factory RTCStatus.declined() = RTCStatus_Declined;
  const factory RTCStatus.sending() = RTCStatus_Sending;
  const factory RTCStatus.finished() = RTCStatus_Finished;
  const factory RTCStatus.error(
    String field0,
  ) = RTCStatus_Error;
}

@freezed
sealed class WsServerMessage with _$WsServerMessage {
  const WsServerMessage._();

  const factory WsServerMessage.hello({
    required ClientInfo client,
    required List<ClientInfo> peers,
  }) = WsServerMessage_Hello;
  const factory WsServerMessage.join({
    required ClientInfo peer,
  }) = WsServerMessage_Join;
  const factory WsServerMessage.update({
    required ClientInfo peer,
  }) = WsServerMessage_Update;
  const factory WsServerMessage.left({
    required UuidValue peerId,
  }) = WsServerMessage_Left;
  const factory WsServerMessage.offer(
    WsServerSdpMessage field0,
  ) = WsServerMessage_Offer;
  const factory WsServerMessage.answer(
    WsServerSdpMessage field0,
  ) = WsServerMessage_Answer;
  const factory WsServerMessage.error({
    required int code,
  }) = WsServerMessage_Error;
}

class WsServerSdpMessage {
  final ClientInfo peer;
  final String sessionId;
  final String sdp;

  const WsServerSdpMessage({
    required this.peer,
    required this.sessionId,
    required this.sdp,
  });

  @override
  int get hashCode => peer.hashCode ^ sessionId.hashCode ^ sdp.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WsServerSdpMessage &&
          runtimeType == other.runtimeType &&
          peer == other.peer &&
          sessionId == other.sessionId &&
          sdp == other.sdp;
}
